#!/usr/bin/python3
# -*- encoding:utf-8 -*-
# vim: set filetype=python

__copyright__= "Copyright (C) 2019 Wu Xiaotian <yetist@gmail.com>"
__license__  = """
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""

import os
import sys
import shlex
import stat
import json
import argparse
import subprocess

class Result:
    pass

class ShortIO(object):
    def __init__ (self, max_lines=0):
        self.head_lines = int(max_lines/2)
        self.tail_lines = int(max_lines - self.head_lines)
        self.line_count = 0
        self.tail_list = []

    def print(self, msg):
        if self.head_lines <= 0 or self.tail_lines <= 0:
            print(msg, end='', flush=True)
            return
        if self.line_count < self.head_lines:
            print(msg, end='', flush=True)
        else:
            print('.', end='', flush=True)
            self.tail_list.append(msg)
            if len(self.tail_list) > self.tail_lines:
                self.tail_list = self.tail_list[self.tail_lines:]
        self.line_count += 1

    def end(self):
        if self.head_lines <= 0 or self.tail_lines <= 0:
            return
        result = self.line_count - self.head_lines - self.tail_lines
        if result > 0:
            print(' Hidden %d lines of output here ......' % result)
        else:
            print()
        for line in self.tail_list:
            print(line, end='', flush=True)

class bcolors:
    CEND    = '\33[0m'
    CRED    = '\33[31m'
    CBOLD   = '\33[1m'
    CGREEN  = '\33[32m'
    CBLUE   = '\33[34m'

def _color_print(color, msg):
    print(color + msg + bcolors.CEND)

def print_info(msg):
    _color_print(bcolors.CGREEN, msg)

def print_cmdline(msg):
    _color_print(bcolors.CBLUE, ">>> [%s] <<<" % msg)

def print_error(msg):
    _color_print(bcolors.CRED, '!!! ERROR: ')
    print(msg)

def parse_args():
    parser = argparse.ArgumentParser(description='Compile the software in a Docker container')
    parser.add_argument('-i', '--install', dest='install', action='store_true', help='Install dependent packages before compilation.')
    parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('-C', '--clean', dest='clean', action='store_true', help='Clean up the Docker container after completion.')
    parser.add_argument('-n', '--name',  dest='name', action='store', default='fedora', help='Docker image name, default is "fedora". Can write a tag, such as "ubuntu:18.10".')
    parser.add_argument('-l', '--lines',  dest='lines', action='store', type=int, default=100, help='The maximum number of lines to output, default is 100. Set to 0 or less than 0 means no limit. If --verbose is enabled, the value is ignored as unlimited.')
    parser.add_argument('-c', '--config',  dest='config', action='store', default='.docker-build.yml', help='Configuration file path, default is ".docker-build.yml".')
    parser.add_argument('-b', '--build', dest='build', action='store', choices={'autotools','meson'}, help='The build type, can be "autotools" or "meson".')

    return parser.parse_args()

def load_config (cfgfile):
    cfg = {}
    if os.path.isfile(cfgfile):
        fp = open(cfgfile)
        if cfgfile.endswith(".yml") or cfgfile.endswith(".yaml"):
            cfg = yaml.load(fp)
        elif cfgfile.endswith(".js") or cfgfile.endswith(".json"):
            cfg = json.load(fp)
        fp.close()
    return cfg

def run_cmd(command, opts):
    print_cmdline(command)

    result = Result()
    if opts['verbose']:
        io = ShortIO(-1)
    else:
        io = ShortIO(opts['max_lines'])
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE, bufsize=1)
    for line in iter(p.stdout.readline, b''):
        io.print(line.decode('utf-8'))
    io.end()
    p.stdout.close()
    p.wait()

    result.exit_code = p.returncode
    result.command = command

    return result

def docker_pull (opts):
    image_name = "%s:%s" % (opts['distro_name'], opts['distro_version'])
    cmd = "docker pull %s" % image_name
    result = run_cmd (cmd, opts)
    if result.exit_code != 0:
        sys.exit(1)

def docker_run_daemon (command, opts):
    container_name = opts['container_name']
    host_dir = opts['host_dir']
    image_name = "%s:%s" % (opts['distro_name'], opts['distro_version'])

    cmd = "docker run --name %s --volume %s:/rootdir -t -d %s %s" % (container_name, host_dir, image_name, command)
    result = run_cmd (cmd, opts)
    if result.exit_code != 0:
        sys.exit(1)

def docker_exec (command, opts):
    container_name = opts['container_name']
    cmd = "docker exec -t %s %s" % (container_name, command)
    result = run_cmd (cmd, opts)
    if result.exit_code != 0:
        sys.exit(1)

def docker_is_running (opts):
    cmd = "docker inspect -f '{{.State.Running}}' %s" % opts['container_name']
    result = run_cmd (cmd, opts)
    return result.exit_code == 0

def docker_kill (opts):
    cmd = "docker container kill %s" % opts['container_name']
    result = run_cmd (cmd, opts)
    if result.exit_code != 0:
        sys.exit(1)

def docker_rm (opts):
    cmd = "docker container rm %s" % opts['container_name']
    result = run_cmd (cmd, opts)
    if result.exit_code != 0:
        sys.exit(1)

# The follow commands running in the docker.
def system_update (opts):
    docker_exec (opts['distro_upgrade'], opts)

def system_install (opts):
    if 'requires' not in opts['config'].keys():
        return

    distro_name = opts['distro_name']
    if distro_name in opts['config']['requires'].keys():
        distro_requires = opts['config']['requires'][distro_name]
        if distro_requires:
            requires = ' '.join(distro_requires)
        else:
            requires = 'gcc git make'
        cmd = '%s %s' % (opts['install_command'], requires)
        docker_exec (cmd, opts)

def get_repo_name():
    cmd = 'git rev-parse --show-toplevel'
    output = subprocess.check_output(cmd, shell=True)
    output = output.decode("utf-8")
    return os.path.basename(output.strip())

def build_run(script, cmdline, opts):
    fp = open(script, 'w+')
    fp.write('#!/bin/bash\n\n')
    if args.verbose:
        fp.write('set -x\n\n')

    # Setup envirment variables
    if 'variables' in opts['config'].keys():
        for var in opts['config']['variables']:
            if var.find('=') > 0:
                fp.write ("export %s\n" % var)

    # export option setup as envirment variables
    for k, v in opts.items():
        if k in ['config', 'distro_upgrade', 'install_command', 'host_dir']:
            continue
        fp.write ("export %s=%s\n" % (k.upper(), str(v).lower()))

    fp.write('cd /rootdir\n')
    fp.write(' && '.join(cmdline))
    fp.write('\n')
    fp.close()
    os.chmod(script, stat.S_IRWXU |stat.S_IXGRP|stat.S_IXOTH)
    docker_exec(os.path.join('/rootdir/', script), opts)

def setup_options(args, config):
    option = {
            'build_type' : 'autotools',
            'distro_name' : 'fedora',
            'distro_version' : 'latest',
            'max_lines' : args.lines,
            'host_dir' : os.path.dirname(os.path.abspath(__file__)),
            'start_dir' : '/rootdir',
            'build_dir' : '/rootdir',
            'verbose' : args.verbose,
            'config' : config,
            }

    # parse distro
    distro = args.name.split(':')
    distro_name = distro[0]
    if distro_name.find('/') > 0:
        distro_name = distro_name.rsplit('/',1)[-1]

    option['distro_name'] = distro_name
    option['container_name'] = "%s-%s-build" % (get_repo_name(), option['distro_name'])
    if distro_name == 'archlinux':
        option['distro_upgrade'] = 'pacman -Syu --noconfirm'
        option['install_command'] = 'pacman -Sy --noconfirm'
    elif distro_name == 'centos':
        option['distro_upgrade'] = 'yum update -y'
        option['install_command'] = 'yum install -y'
    if distro_name == 'fedora':
        option['distro_upgrade'] = 'dnf update -y'
        option['install_command'] = 'dnf install -y'
    elif distro_name == 'debian' or distro_name == 'ubuntu':
        option['distro_upgrade'] = 'apt-get update -y'
        option['install_command'] = 'apt-get install -y'
    else:
        url = 'https://github.com/mate-desktop/mate-dev-scripts/issues/new'
        msg = 'The "%s" distro is not supported, please visit "%s" to create a new issue.' % (distro_name, url)
        print_error(msg)
        sys.exit(1)

    if len(distro) > 1:
        option['distro_version'] = distro[-1]

    if args.build == 'meson':
        option['build_type'] = 'meson'
        option['build_dir'] = os.path.join(option['start_dir'], '_build')

    return option

# Run in docker
def run_scripts(opts, stage = 'before'):
    script_name = stage + '_scripts'
    if script_name not in opts['config'].keys():
        return
    build_run (script_name, opts['config'][script_name], opts)

def autotools_build (opts):
    configures = '--prefix=/usr'
    if 'configures' in opts['config'].keys() and 'autotools' in opts['config']['configures'].keys():
        configures = ' '.join(opts['config']['configures']['autotools'])

    cmdlines = []
    if os.path.isfile('./autogen.sh'):
        cmdlines.append('./autogen.sh ' + configures)
    elif os.path.isfile('./configure'):
        cmdlines.append('./configure ' + configures)

    if os.path.isfile('./autogen.sh') or os.path.isfile('./configure'):
        cmdlines.append('make')
        build_run ('src_build', cmdlines, opts)

def meson_build (opts):
    configures = '--prefix /usr'
    if 'configures' in opts['config'].keys() and 'meson' in opts['config']['configures'].keys():
        configures = ' '.join(opts['config']['configures']['meson'])

    cmdlines = []
    if os.path.isfile('./meson.build'):
        cmdlines.append('meson _build ' + configures)
        cmdlines.append('cd _build')
        cmdlines.append('ninja')
        build_run ('src_build', cmdlines, opts)

def source_build(opts):
    if opts['build_type'] == 'autotools':
        autotools_build (opts)
    elif opts['build_type'] == 'meson':
        meson_build (opts)

if __name__=="__main__":
    args = parse_args()

    if args.config.endswith('.yml') or args.config.endswith('.yaml'):
        try:
            import yaml
        except:
            run_cmd ("apt-get update -y", {'verbose':True, 'max_lines':100})
            run_cmd ("apt-get install -y python3-yaml", {'verbose':True, 'max_lines':100})
            try:
                import yaml
            except:
                msg = "Can't import 'yaml' python module on the Host OS.\nPlease replace the '%s' file with a JSON file.\n" % args.config
                print_error(msg)
                sys.exit(1)

    config = load_config(args.config)
    opts = setup_options(args, config)

    if args.install:
        docker_pull(opts)
        if not docker_is_running (opts):
            docker_run_daemon('/bin/bash', opts)
        system_update(opts)
        system_install(opts)

    if args.build:
        run_scripts(opts, 'before')
        source_build(opts)
        run_scripts(opts, 'after')

    if args.clean and docker_is_running (opts):
        docker_kill (opts)
        docker_rm (opts)
