#!/usr/bin/python3
# -*- encoding:utf-8 -*-
# vim: set filetype=python

__copyright__= "Copyright (C) 2019 Wu Xiaotian <yetist@gmail.com>"
__license__  = """
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""

import os
import sys
import shlex
import stat
import json
import argparse
import subprocess
import shutil

MESON_BUILD_DIRNAME = '_build'

class Result:
    pass

class ShortIO(object):
    def __init__ (self, limit=0):
        self.head_lines = int(limit/2)
        self.tail_lines = int(limit - self.head_lines)
        self.line_count = 0
        self.tail_list = []

    def print(self, msg):
        if self.head_lines <= 0 or self.tail_lines <= 0:
            print(msg, end='', flush=True)
            return
        if self.line_count < self.head_lines:
            print(msg, end='', flush=True)
        else:
            print('.', end='', flush=True)
            self.tail_list.append(msg)
            if len(self.tail_list) > self.tail_lines:
                self.tail_list = self.tail_list[self.tail_lines:]
        self.line_count += 1

    def end(self):
        if self.head_lines <= 0 or self.tail_lines <= 0:
            return
        result = self.line_count - self.head_lines - self.tail_lines
        if result > 0:
            print(' %d lines of output are not displayed ......' % result)
        else:
            print()
        for line in self.tail_list:
            print(line, end='', flush=True)

class bcolors:
    CEND    = '\33[0m'
    CRED    = '\33[31m'
    CBOLD   = '\33[1m'
    CGREEN  = '\33[32m'
    CBLUE   = '\33[34m'

def _color_print(color, msg):
    print(color + msg + bcolors.CEND)

def print_info(msg):
    _color_print(bcolors.CGREEN, msg)

def print_cmdline(msg):
    _color_print(bcolors.CBLUE, ">>> [%s] <<<" % msg)

def print_error(msg):
    _color_print(bcolors.CRED, '!!! ERROR: %s' % msg)
    #print(msg)

def parse_args():
    parser = argparse.ArgumentParser(description='Compile the software in a Docker container')
    parser.add_argument('-c', '--config',  dest='config', metavar='FILE', action='store', default='.docker-build.yml', help='The config file (default is ".docker-build.yml")')
    parser.add_argument('-n', '--name',  dest='name', metavar='IMAGE', action='store', default='fedora', help='Docker image name (default is "fedora")')
    parser.add_argument('-l', '--limit',  dest='limit', metavar='N', action='store', type=int, default=100, help='Limit the number of output lines (default is 100)')
    parser.add_argument('-s', '--shell', dest='shell', action='store_true', help='Run interactive bash in the docker container.')
    parser.add_argument('-v', '--verbose', dest='verbose', action='count', default=0, help='Verbose output, the number of output lines is not limited')
    parser.add_argument('-i', '--install', dest='install', action='store_true', help='Install dependent packages in docker container.')
    parser.add_argument('-b', '--build', dest='build', metavar='autotools|meson', action='append', help='Compile the software in docker container.')
    parser.add_argument('-C', '--clean', dest='clean', action='store_true', help='Clean up the docker container.')

    return parser.parse_args()

def load_config (cfgfile):
    cfg = {}
    if os.path.isfile(cfgfile):
        fp = open(cfgfile)
        if cfgfile.endswith(".yml") or cfgfile.endswith(".yaml"):
            cfg = yaml.load(fp)
        elif cfgfile.endswith(".js") or cfgfile.endswith(".json"):
            cfg = json.load(fp)
        fp.close()
    return cfg

def run_cmd(command, opts):
    print_cmdline(command)
    if command.startswith('docker exec'):
        sh = command.split()[-1].strip()
        shpath = os.path.join(opts['host_dir'], os.path.basename(sh))
        if os.path.isfile(shpath):
            print('# cat %s' % sh)
            print(open(shpath).read())
            print('# %s' % sh)

    result = Result()
    if opts['stage'] == 'src_build':
        if opts['verbose'] > 0:
            io = ShortIO(-1)
        else:
            io = ShortIO(opts['limit'])
    elif opts['stage'] == 'after_scripts':
        if opts['verbose'] > 1:
            io = ShortIO(-1)
        else:
            io = ShortIO(opts['limit'])
    elif opts['stage'] == 'before_scripts':
        if opts['verbose'] > 2:
            io = ShortIO(-1)
        else:
            io = ShortIO(opts['limit'])
    elif opts['stage'] == 'system_install':
        if opts['verbose'] > 3:
            io = ShortIO(-1)
        else:
            io = ShortIO(opts['limit'])
    else:
        io = ShortIO(opts['limit'])
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE, bufsize=1)
    for line in iter(p.stdout.readline, b''):
        io.print(line.decode('utf-8'))
    io.end()
    p.stdout.close()
    p.wait()

    result.exit_code = p.returncode
    if opts['verbose'] > 0 and p.returncode != 0:
        print_error('run command [%s].' % command)
    result.command = command

    return result

def docker_pull (opts):
    image_name = opts['image_name']
    opts['stage'] = 'docker_pull'
    cmd = "docker pull %s" % image_name
    result = run_cmd (cmd, opts)
    if result.exit_code != 0:
        sys.exit(1)

def docker_run_daemon (command, opts):
    container_name = opts['container_name']
    host_dir = opts['host_dir']
    image_name = opts['image_name']
    opts['stage'] = 'docker_run_daemon'

    cmd = "docker run --name %s --volume %s:/rootdir -t -d %s %s" % (container_name, host_dir, image_name, command)
    result = run_cmd (cmd, opts)
    if result.exit_code != 0:
        sys.exit(1)

def docker_exec (command, opts):
    container_name = opts['container_name']
    cmd = "docker exec -t %s %s" % (container_name, command)
    result = run_cmd (cmd, opts)
    if result.exit_code != 0:
        sys.exit(1)

def docker_is_running (opts):
    opts['stage'] = 'docker_is_running'
    cmd = "docker inspect -f '{{.State.Running}}' %s" % opts['container_name']
    result = run_cmd (cmd, opts)
    return result.exit_code == 0

def docker_kill (opts):
    opts['stage'] = 'docker_kill'
    cmd = "docker container kill %s" % opts['container_name']
    result = run_cmd (cmd, opts)
    if result.exit_code != 0:
        sys.exit(1)

def docker_rm (opts):
    opts['stage'] = 'docker_rm'
    cmd = "docker container rm %s" % opts['container_name']
    result = run_cmd (cmd, opts)
    if result.exit_code != 0:
        sys.exit(1)

# The follow commands running in the docker.
def system_shell(opts):
    opts['stage'] = 'system_shell'
    if docker_is_running (opts):
        cmd = "docker exec -it %s /bin/bash" % opts['container_name']
        os.system(cmd)
    else:
        print_error('The docker container "%s" is not running.' % opts['container_name'])

def system_update (opts):
    if not opts['travis']:
        hook_name = 'distro_hook'
        host_hook_path = os.path.join(opts['host_dir'], hook_name)
        user_hook_path = os.path.expanduser('~/.%s' % hook_name)
        if not os.path.isfile(host_hook_path) and os.path.isfile(user_hook_path):
            shutil.copy(user_hook_path, host_hook_path)
        if os.path.isfile(host_hook_path):
            os.chmod(host_hook_path, stat.S_IRWXU |stat.S_IXGRP|stat.S_IXOTH)
            cmd = '/rootdir/%s %s' % (hook_name, opts['distro_name'])
            opts['stage'] = hook_name
            docker_exec (cmd, opts)
    opts['stage'] = 'system_update'
    docker_exec (opts['distro_upgrade'], opts)

def system_install (opts):
    if 'requires' not in opts['config'].keys():
        return

    opts['stage'] = 'system_install'
    distro_name = opts['distro_name']
    if distro_name in opts['config']['requires'].keys():
        distro_requires = opts['config']['requires'][distro_name]
        if distro_requires:
            requires = ' '.join(distro_requires)
        else:
            requires = 'gcc git make'
        cmd = '%s %s' % (opts['install_command'], requires)
        docker_exec (cmd, opts)

def get_repo_name():
    cmd = 'git rev-parse --show-toplevel'
    output = subprocess.check_output(cmd, shell=True)
    output = output.decode("utf-8")
    return os.path.basename(output.strip())

def build_run(script, cmdline, opts):
    opts['stage'] = script
    shpath = os.path.join(opts['host_dir'], script)
    fp = open(shpath, 'w+')
    fp.write('#!/bin/bash\n')
    if opts['verbose']:
        fp.write('set -x\n\n')

    # Setup envirment variables
    if 'variables' in opts['config'].keys():
        for var in opts['config']['variables']:
            if var.find('=') > 0:
                fp.write ("export %s\n" % var)

    # export option setup as envirment variables
    for k, v in opts.items():
        if k in ['config', 'distro_upgrade', 'install_command', 'host_dir', 'image_name']:
            continue
        fp.write ("export %s=%s\n" % (k.upper(), str(v).lower()))

    fp.write('\n')
    fp.write('cd /rootdir\n\n')
    for line in cmdline:
        fp.write('%s\n' % line)
    fp.close()
    os.chmod(shpath, stat.S_IRWXU |stat.S_IXGRP|stat.S_IXOTH)
    docker_exec(os.path.join('/rootdir/', script), opts)

def setup_options(args, config):
    option = {
            'build_type' : 'autotools',
            'distro_name' : 'fedora',
            'distro_version' : 'latest',
            'stage' : 'default',
            'image_name' : args.name,
            'limit' : args.limit,
            'host_dir' : os.getcwd(),
            'start_dir' : '/rootdir',
            'build_dir' : '/rootdir',
            'verbose' : args.verbose,
            'config' : config,
            'travis' : bool(os.getenv("TRAVIS")),
            }

    if option['travis']:
        option['host_dir'] = os.path.dirname(os.path.abspath(__file__)),

    # Remove duplicate elements from args.build
    if args.build:
        args.build = sorted(set(args.build), key=args.build.index)

    # parse distro
    distro = args.name.split(':')
    distro_name = distro[0]
    if distro_name.find('/') > 0:
        distro_name = distro_name.rsplit('/',1)[-1]

    option['distro_name'] = distro_name
    option['container_name'] = "%s-%s-build" % (get_repo_name(), option['distro_name'])
    if distro_name == 'archlinux':
        option['distro_upgrade'] = 'pacman -Syu --noconfirm'
        option['install_command'] = 'pacman -Sy --noconfirm'
    elif distro_name == 'centos':
        option['distro_upgrade'] = 'yum update -y'
        option['install_command'] = 'yum install -y'
    elif distro_name == 'fedora':
        option['distro_upgrade'] = 'dnf update -y'
        option['install_command'] = 'dnf install -y'
    elif distro_name == 'debian' or distro_name == 'ubuntu':
        option['distro_upgrade'] = 'apt-get update -y'
        option['install_command'] = 'env DEBIAN_FRONTEND=noninteractive apt-get install -y'
    else:
        url = 'https://github.com/mate-desktop/mate-dev-scripts/issues/new'
        msg = 'The "%s" distro is not supported, please visit "%s" to create a new issue.' % (distro_name, url)
        print_error(msg)
        sys.exit(1)

    if len(distro) > 1:
        option['distro_version'] = distro[-1]

    return option

# Run in docker
def run_scripts(opts, stage = 'before'):
    script_name = stage + '_scripts'
    if script_name not in opts['config'].keys():
        return
    build_run (script_name, opts['config'][script_name], opts)

def autotools_build (opts):
    configures = '--prefix=/usr'
    if 'configures' in opts['config'].keys() and 'autotools' in opts['config']['configures'].keys():
        configures = ' '.join(opts['config']['configures']['autotools'])

    cmdlines = []
    if os.path.isfile('./autogen.sh') or os.path.isfile('./configure'):
        if os.path.isfile('./autogen.sh'):
            cmdlines.append('./autogen.sh ' + configures)
        elif os.path.isfile('./configure'):
            cmdlines.append('./configure ' + configures)
        if not opts['travis']:
            cmdlines.append('make clean')
        cmdlines.append('make')
        build_run ('src_build', cmdlines, opts)

def meson_build (opts):
    configures = '--prefix /usr'
    if 'configures' in opts['config'].keys() and 'meson' in opts['config']['configures'].keys():
        configures = ' '.join(opts['config']['configures']['meson'])

    cmdlines = []
    if os.path.isfile('./meson.build'):
        if not opts['travis']:
            cmdlines.append('[ -d %s ] && rm -rf %s' % (MESON_BUILD_DIRNAME, MESON_BUILD_DIRNAME))
        cmdlines.append('meson %s %s' % (MESON_BUILD_DIRNAME, configures))
        cmdlines.append('cd %s' % (MESON_BUILD_DIRNAME))
        cmdlines.append('ninja')
        build_run ('src_build', cmdlines, opts)

def source_build(build_type, opts):
    opts['build_type'] = build_type
    if build_type == 'meson':
        opts['build_dir'] = os.path.join(opts['start_dir'], MESON_BUILD_DIRNAME)
    else:
        opts['build_dir'] = opts['start_dir']

    run_scripts(opts, 'before')
    if build_type == 'autotools':
        autotools_build (opts)
    elif opts['build_type'] == 'meson':
        meson_build (opts)
    else:
        print_info ('Build system "%s" is not supported.' % build_type)
    run_scripts(opts, 'after')

if __name__=="__main__":
    args = parse_args()

    if args.config.endswith('.yml') or args.config.endswith('.yaml'):
        try:
            import yaml
        except:
            run_cmd ("apt-get update -y", {'verbose':True, 'limit':100})
            run_cmd ("apt-get install -y python3-yaml", {'verbose':True, 'limit':100})
            try:
                import yaml
            except:
                msg = "Can't import 'yaml' python module on the Host OS.\nPlease replace the '%s' file with a JSON file.\n" % args.config
                print_error(msg)
                sys.exit(1)

    config = load_config(args.config)
    opts = setup_options(args, config)

    if args.shell:
        system_shell(opts)
        sys.exit(0)

    if args.install:
        docker_pull(opts)
        if not docker_is_running (opts):
            docker_run_daemon('/bin/bash', opts)
        system_update(opts)
        system_install(opts)

    if args.build:
        for i in args.build:
            source_build(i, opts)

    if args.clean:
        if docker_is_running (opts):
            docker_kill (opts)
        docker_rm (opts)
