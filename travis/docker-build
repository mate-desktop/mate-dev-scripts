#!/usr/bin/python3
# -*- encoding:utf-8 -*-
# vim: set filetype=python

__copyright__= "Copyright (C) 2019 Wu Xiaotian <yetist@gmail.com>"
__license__  = """
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
"""

import os
import sys
import shlex
import stat
import json
import argparse
import subprocess

class Result:
    pass

class bcolors:
    CEND    = '\33[0m'
    CRED    = '\33[31m'
    CBOLD   = '\33[1m'
    CGREEN  = '\33[32m'
    CBLUE   = '\33[34m'

def _color_print(color, msg):
    print(color + msg + bcolors.CEND)

def print_info(msg):
    _color_print(bcolors.CGREEN, msg)

def print_cmdline(msg):
    _color_print(bcolors.CBLUE, ">>> [%s] <<<" % msg)

def print_error(msg):
    _color_print(bcolors.CRED, '!!! ERROR: ')
    print(msg)

def parse_args():
    parser = argparse.ArgumentParser(description='Compile the software in a Docker container')
    parser.add_argument('-i', '--install', dest='install', action='store_true', help='Install dependent packages before compilation.')
    parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='Enable verbose output')
    parser.add_argument('-C', '--clean', dest='clean', action='store_true', help='Clean up the Docker container after completion.')
    parser.add_argument('-n', '--name',  dest='name', action='store', default='fedora', help='Docker image name, default is "fedora". Can write a tag, such as "ubuntu:18.10".')
    parser.add_argument('-c', '--config',  dest='config', action='store', default='.docker-build.yml', help='Configuration file path, default is ".docker-build.yml".')
    parser.add_argument('-b', '--build', dest='build', action='store', choices={'autotools','meson'}, help='The build type, can be "autotools" or "meson".')

    return parser.parse_args()

def load_config (cfgfile):
    cfg = {}
    if os.path.isfile(cfgfile):
        fp = open(cfgfile)
        if cfgfile.endswith(".yml") or cfgfile.endswith(".yaml"):
            cfg = yaml.load(fp)
        elif cfgfile.endswith(".js") or cfgfile.endswith(".json"):
            cfg = json.load(fp)
        fp.close()
    return cfg

def run_cmd(command):
    print_cmdline(command)

    result = Result()
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE, bufsize=1)
    for line in iter(p.stdout.readline, b''):
        print(line.decode('utf-8'), end='', flush=True)
    p.stdout.close()
    p.wait()

    result.exit_code = p.returncode
    result.command = command

    return result

def docker_pull (image_name):
    cmd = "docker pull %s" % args.name
    result = run_cmd (cmd)
    if result.exit_code != 0:
        sys.exit(1)

def docker_run_daemon (image_name, container_name, cmdline):
    cmd = "docker run --name %s --volume %s:/rootdir -t -d %s %s" % (container_name, os.getcwd(), image_name, cmdline)
    result = run_cmd (cmd)
    if result.exit_code != 0:
        sys.exit(1)

def docker_exec (container_name, cmdline):
    cmd = "docker exec -t %s %s" % (container_name, cmdline)
    result = run_cmd (cmd)
    if result.exit_code != 0:
        sys.exit(1)

def docker_is_running (container_name):
    cmd = "docker inspect -f '{{.State.Running}}' %s" % container_name
    result = run_cmd (cmd)
    return result.exit_code == 0

def docker_kill (container_name):
    cmd = "docker container kill %s" % container_name
    result = run_cmd (cmd)
    if result.exit_code != 0:
        sys.exit(1)

def docker_rm (container_name):
    cmd = "docker container rm %s" % container_name
    result = run_cmd (cmd)
    if result.exit_code != 0:
        sys.exit(1)

def system_update (distro, container_name):
    update_cmd = ''
    if distro == 'archlinux':
        update_cmd = 'pacman -Syu --noconfirm'
    elif distro == 'centos':
        update_cmd = 'yum update -y'
    if distro == 'fedora':
        update_cmd = 'dnf update -y'
    elif distro == 'debian' or distro == 'ubuntu':
        update_cmd = 'apt-get update -y'
    if len(update_cmd) > 0:
        docker_exec (container_name, update_cmd)

def system_install (distro, container_name):
    if 'requires' not in config.keys():
        return
    if distro in config['requires'].keys():
        requires = ' '.join(config['requires'][distro])
        if distro == 'archlinux':
            cmd = 'pacman -Sy --noconfirm %s' % requires
        elif distro == 'centos':
            cmd = 'yum install -y %s' % requires
        if distro == 'fedora':
            cmd = 'dnf install -y %s' % requires
        elif distro == 'debian' or distro == 'ubuntu':
            cmd = 'apt-get install -y %s' % requires
        docker_exec (container_name, cmd)

def get_repo_name():
    cmd = 'git rev-parse --show-toplevel'
    output = subprocess.check_output(cmd, shell=True)
    output = output.decode("utf-8")
    return os.path.basename(output.strip())

def build_run (container_name, shfile, cmdlines, variables=[]):
    fp = open(shfile, 'w+')
    fp.write('#!/bin/bash\n\n')
    if args.verbose:
        fp.write('set -x\n\n')
    for var in variables:
        if var.find('=') > 0:
            fp.write ("export %s\n" % var)
    fp.write('cd /rootdir\n')
    fp.write(' && '.join(cmdlines))
    fp.write('\n')
    fp.close()
    os.chmod(shfile, stat.S_IRWXU |stat.S_IXGRP|stat.S_IXOTH)
    docker_exec (container_name, os.path.join('/rootdir/', shfile))

def before_scripts(container_name):
    if 'before_scripts' not in config.keys():
        return

    env = ['BUILD_TYPE=autotools']
    if args.build == 'meson':
        env = ['BUILD_TYPE=meson']

    build_run (container_name, 'before_scripts', config['before_scripts'], env)

def after_scripts(container_name):
    if 'after_scripts' not in config.keys():
        return

    env = ['BUILD_TYPE=autotools']
    if args.build == 'meson':
        config['after_scripts'].insert(0, "cd _build")
        env = ['BUILD_TYPE=meson']

    build_run (container_name, 'after_scripts', config['after_scripts'], env)

def autotools_build (container_name):
    configures = '--prefix=/usr'
    if 'configures' in config.keys() and 'autotools' in config['configures'].keys():
        configures = ' '.join(config['configures']['autotools'])

    cmdlines = []
    if os.path.isfile('./autogen.sh'):
        cmdlines.append('./autogen.sh ' + configures)
    elif os.path.isfile('./configure'):
        cmdlines.append('./configure ' + configures)

    if os.path.isfile('./autogen.sh') or os.path.isfile('./configure'):
        cmdlines.append('make')
        if 'variables' in config.keys():
            build_run (container_name, 'src_build', cmdlines, config['variables'])
        else:
            build_run (container_name, 'src_build', cmdlines)

def meson_build (container_name):
    configures = '--prefix /usr'
    if 'configures' in config.keys() and 'meson' in config['configures'].keys():
        configures = ' '.join(config['configures']['meson'])

    cmdlines = []
    if os.path.isfile('./meson.build'):
        cmdlines.append('meson _build ' + configures)
        cmdlines.append('cd _build')
        cmdlines.append('ninja')
        if 'variables' in config.keys():
            build_run (container_name, 'src_build', cmdlines, config['variables'])
        else:
            build_run (container_name, 'src_build', cmdlines)

def source_build(build_type, container_name):
    if build_type == "autotools":
        autotools_build (container_name)
    elif build_type == "meson":
        meson_build (container_name)

if __name__=="__main__":
    args = parse_args()

    if args.config.endswith('.yml') or args.config.endswith('.yaml'):
        try:
            import yaml
        except:
            run_cmd ("apt-get update -y")
            run_cmd ("apt-get install -y python3-yaml")
            try:
                import yaml
            except:
                print_error("Don't use '%s' as config file\n" % args.config)
                sys.exit(1)

    config = load_config(args.config)

    distro = args.name.split(':')[0]
    if distro.find('/') > 0:
        distro = distro.rsplit('/',1)[-1]
    container_name = "%s-%s-build" % (get_repo_name(), distro)

    if args.install:
        docker_pull(args.name)
        if not docker_is_running (container_name):
            docker_run_daemon(args.name, container_name, '/bin/bash')
        system_update(distro, container_name)
        system_install(distro, container_name)

    if args.build:
        before_build_script(container_name)
        source_build(args.build, container_name)
        after_build_script(container_name)
        if args.clean and docker_is_running (container_name):
            docker_kill (container_name)
            docker_rm (container_name)
